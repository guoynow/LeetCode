# 一、基础算法



## 快排

```cpp
void quick_sort(int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = arr[l + r >> 1];
    while (i < j) {
        while (arr[++ i] < x);
        while (arr[-- j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }
    quick_sort(l, j), quick_sort(j + 1, r);
}
```



## 归并

```c++
void merge_sort(int l, int r) {
    if(l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r) {
        if(a[i] <= a[j])
            tmp[k ++] = a[i ++];
        else
            tmp[k ++] = a[j ++];
    }
    while(i <= mid) tmp[k ++] = a[i ++];
    while(j <= r) tmp[k ++] = a[j ++];
    for(int i = l, j = 0; i <= r; i ++, j ++)
        a[i] = tmp[j];
}

```



## 高精二分

```c++
/* 
最左边第一个等于k的下标 
*/

int SL(int k) {
    int l = -1, r = n;
    while (l + 1 < r) {
        int mid = l + r >> 1;
        if (arr[mid] < k) l = mid;
        else r = mid;
    }
    return arr[r] == k? r: -1;
}

/* 
最右边第一个等于k的下标 
*/

int SR(int k) {
    int l = -1, r = n;
    while (l + 1 < r) {
        int mid = l + r >> 1;
        if (arr[mid] > k) r = mid;
        else l = mid;
    }
    return arr[l] == k? l: -1;
}
```



## 高精浮点数

```c++
const double eps = 1e-8;   // eps表示精度，取决于题目对精度的要求
// r - l > eps，即r == l，注意大值减小值
```



## 前缀和

```c++
/* 
一维前缀和 
*/

// 预处理出s[]，s[i]存储前i个数的和
s[i] = a[1] + a[2] + ... + a[i];
// 计算[l, r]区间和：
// s[r] - s[l - 1]


/* 
二维前缀和 
*/

// 左上角坐标为(1, 1)，右下角坐标为(i, j)的前缀和（区域内所有数的和）
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
// 计算左上角坐标为(x1, y1)，右下角坐标为(x2, y2)的前缀和：
// s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1-1];
```



## 差分

```c++
/* 
一维差分 
*/

int b[N];       
// b为差分数组，直接定义为全局即可，如果要对某个数组进行差分操作，直接先将该数组中每个数进行
// insert(i, i, a[i])操作即可得到a的差分数组b
// 对区间[l, r]进行差分操作时
void insert(int l,int r,int c) {
	b[l] += c;
	b[r + 1] -= c;
}
// 差分完后对b数组求前缀和即可，求完前缀和后的 b 数组即进行完对某些区间加减某个数操作后的原数组

/* 
二维差分 
*/

int b[N][N];     // 差分数组 
// 对左上角坐标为(l1, r1)，右下角坐标为(l2, r2)的矩阵进行差分操作时
void insert(int l1, int r1, int l2, int r2, int c) {
	b[l1][r1] += c;
	b[l1][r2 + 1] -= c;
	b[l2 + 1][r1] -= c;
	b[l2 + 1][r2 + 1] += c; 
} 
// 同样，差分操作完成后对b数组求前缀和，即可得到对原数组某些区域加减某个数后操作的原数组
```



## 双指针

```c++
// 对于一个序列，用两个指针维护一段区间:
for (int l = 0, r = 0; r < n; r ++ ) {
    while (l < r && check(l, r)) l ++ ;
    // 具体问题的逻辑
}

// 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```



## 位运算

```c++
// 求n的二进制第k位数字: 
int kbit(int x) {
    return n >> k & 1；
}

// 返回n的最后一位1:
int lowbit(int x) {
    return x & -x;
}
```



## 离散化

```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int SL(int x) { // 找到第一个大于等于x的位置
    int l = -1, r = alls.size();
    while (l + 1 < r) {
        int mid = l + r >> 1;
        if (alls[mid] < x) l = mid;
        else r = mid;
    }
    return r + 1; // 映射到1, 2, ... , n
}
```



## 区间合并

```c++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs) {
    vector<PII> res;
    
    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first) {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});
	// 有两个作用：1.防止n为0，把[-无穷，-无穷]压入；2.压入最后一个（也就是当前）的区间，若n>=1，if可以不要
    
    segs = res;
}
```



# 二、数据结构



## 单链表

```c++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a) {
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove() {
    head = ne[head];
}
```



## 双链表

``` c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init() {
    // 0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x) {
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a) {
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```



## 栈

```c++
// tt表示栈顶
int stk[N], tt = -1;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果tt >= 0，则表示不为空
if (tt >= 0) {}
```



## 单调栈

```c++
// 常见模型：找出每个数左边离它最近的比它大/小的数，即第一个比它大/小的数
int tt = -1;
for (int i = 0; i < n; i ++ ) {
    while (tt >= 0 && check(stk[tt], i)) tt -- ; // 小：stack[tt] >= a[i]; 大：stack[tt] <= a[i]
    stk[ ++ tt] = i;
}
```



## 队列

```c++
/* 
普通队列 
*/

// hh表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh <= tt，则表示不为空
if (hh <= tt) {}


/* 
循环队列 
*/

// hh表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt) {}
```



## 单调队列

``` c++
// 常见模型：找出滑动窗口中的最大/小值，即维护一个递减/递增队列（队列存储的是下标，注意访问数组时使用arr[]嵌套q[]）
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ ) { 
    if (hh <= tt && check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口, 即滑动窗口是否已满
    // check_out 滑动窗口是否已满: while (hh <= tt && i - q[hh] + 1 > k) hh ++;
    
    while (hh <= tt && check_in(q[tt], i)) tt -- ;  // 维护一个递减/递增队列
    // check_out 小: arr[i] <= arr[q[tt]]；大: arr[i] >= arr[q[tt]] 
    
    q[ ++ tt] = i; // 注意：下标入队，q[hh] 为滑动窗口中的最大/小值
}
```



## Trie树 (字典树)

```c++
int son[N][26], cnt[N], idx; 
// 0 号点既是根节点，又是空节点
// son[][] 存储树中每个节点的子节点
// cnt[] 存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx; // 判断这个结点是否存在这个字母，如果不存在的话，新创一个结点存储该字母
        p = son[p][u]; // 令 p 指向子结点
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}


/*
应用：最大异或对
*/
void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i -- ) {
        int &s = son[p][x >> i & 1];
        if (!s) s = ++ idx;
        p = s;
    }
}

int search(int x)
{
    int p = 0, res = 0;
    for (int i = 30; i >= 0; i -- ) {
        int s = x >> i & 1;
        if (son[p][!s]) {
            res += 1 << i;
            p = son[p][!s];
        }
        else p = son[p][s];
    }
    return res;
}

// 求解最大异或对
int res = 0
for (int i = 0; i < n; i ++ ) res = max(res, search(a[i]));
```



### 并查集

```c++
/* 
维护 size 的并查集 
*/

int p[N], size[N];
// p[] 存储每个点的祖宗节点，size[] 只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) {
    p[i] = i;
    size[i] = 1;
}

// 合并a和b所在的两个集合：a并入b
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```



## 字符串前缀哈希

```c++
/*
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低，采用字符的ascii码乘上P的次方来计算哈希值
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果
*/

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储(P^k mod 2^64)

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ ) {
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值, 
// 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，
// 乘上 P^2把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。
ULL get(int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}
```



# 三、简单数论



## 筛质数

```c++
int p[N], cnt;
bool st[N];

void isprime(int n) {
    for (int i = 2; i <= n; i ++) {
        if (!st[i]) p[cnt ++] = i;
        for (int j = 0; p[j] <= n / i; j ++ ) {
            st[i * p[j]) = true;
            if(i % p[j] == 0) break;
        }
    }
}
```



## 最大公约数

```c++
int gcd(int a, int b) {
	return b? gcd(b, a % b): a;
}
// 最大公约数与最小公倍数的乘积 = a * b, 故最小公倍数 = a * b / gcd(a, b)
```



## 快速幂

```c++
typedef long long LL;      // 需要快速幂的值一般较大，所以开long long
// 返回a ^ b % p的结果 
int qmi(int a, int b, int p) {
	LL res = 1;
	while(b) {
		if(b & 1) res = res * a % p;
		b >>= 1;
		a=(LL)a * a % p;
	}
	return res;
} 
```



# 四、搜索与图论



## 树与图的存储

```c++
/*
邻接矩阵
*/

g[a][b] = w; // a -> b的权值为w


/*
领接表
*/

// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h); 
```



## 最短路

```c++
/*
Floyd多源最短路：可以有负权边，但不能有负权回路
*/

int n;       // 点数
int d[N][N];       // 邻接矩阵存储图，算法结束后d[i][j]存储i、j之间的最短路径长度 
for(int i = 1; i <= n; i ++ ) {
	for(int j = 1; j <= n; j ++ ) {
		if (i == j) d[i][j] = 0;
		else d[i][j] = 0x3f3f3f3f;
	}
}

void floyd() {
	for(int k = 1; k <= n; k ++ ) {
		for(int i = 1; i <= n; i ++ ) {
			for(int j = 1; j <= n; j ++ ) {
				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
			}
		} 
	}
}
// 注意，若图中存在负权边，此时1号点无法到n号点，d[1][n]也可能被更新，故d[i][j]若大于0x3f3f3f3f/2即可认为最短路不存在 
```



## 最小生成树

```c++
/*
Kruakal：稀疏图
*/

int p[N];            // 并查集父结点数组 

int find(int x) {     // 并查集find操作 
	if(p[x] != x) p[x] = find(p[x]);
	return p[x];
}

struct Edge {      // 存储每条边 
	int a, b, w;
    bool operator < (const Edge &W) const {
        return w < W.w;
    }
}edges[M]; 

int kruskal(){
	for(int i = 1; i <= n; i ++ ) p[i] = i;        // 初始化并查集 
	sort(edges, edges + m);             // 按边权从小到大排序 
    
	int res = 0, cnt =0 ;                    // res记录最小生成树边权之和，cnt记录当前最小生成树种的边数 
	for(int i = 0; i < m; i ++ ) {
		int a = edges[i].a, b = edges[i].b, w = edges[i].w;
		if (find(a) != find(b) ) {           // 最小边权的起点和终点a,b不在一个连通块则合并他们 
			p[find(a)] = find(b);
			res += w;
			cnt ++;
		}
	}
	if(cnt < n - 1) return 0x3f3f3f3f;      // n个点，最小生成树的边应为n-1条，少于n-1说明没有最小生成树 
	else return res;
}
```



# 五、STL



## string

``` c++
#include <string>    
string s = "123465"; // 不能用单引号''

int x = stoi(s);    // x = 123465：将字符串转化成int类型，传入string类型字符串
    
s.size();      // 返回大小
s.empty();     // 判断是否为空
s.clear();     // 清空
    
s.replace(s.begin(), s.begin() + 3, 'abc');  // s = "abc456"：将[s.begin(), s.begin() + 3)处替换为'abc'

ss = s.substr(1, 2);   // ss = "23"，s = "123456"：截取s[1]开始的长度为2的子串，返回子串

p = s.find("234");      // p = 1：查找字符第一次出现的位置，如果没有出现过，则返回string::npos
```



## vector

```c++
#include <vector>  

vector<int> a;
vector<int> a(100, 666); // 初始化100个666


a.size();        // 返回元素个数
a.empty();       // 判空
a.clear();       // 清空

a.push_back(x);               // 在尾部添加x
a.insert(a.begin() + 2, x);   // 在索引2的位置插入x
    
a.pop_back();                       // 删除最后一个元素
a.erase(a.begin(), a.begin() + 3);  // 删除[索引0, 索引2]之间的元素
```



## queue/priority_queue

```c++
#include <queue>   

/*
queue
*/

queue<int> q;

q.size();    // 返回队列中元素的个数
q.empty();   // 判空
q.push(x);    // 在末尾加入一个元素
q.pop();     // 删除第一个元素
q.front();	// 返回队头
q.back();   // 返回队尾
    
/*
priority_queue
*/

priority_queue<int> pq; // 默认定义为大根堆
priority_queue<int,vector<int>,greater<int>> pq; //定义成小根堆方法

pq.size();    // 返回优先队列中元素的个数
pq.empty();  // 判空
pq.push(x);    // 加入一个元素
pq.pop();     // 删除堆顶元素
pq.top();     // 返回堆顶元素
```



## set/multiset

```c++
#include <set>    //set去重，multiset不去重，均默认升序排序，底层红黑树

set<int> s;

s.size();   //返回集合中元素个数
s.empty();  //判空
s.clear();  //清空所有元素
    
s.insert(x);  // 在集合中插入x
s.find(x);    // 查找x，如果找到则返回x第一次出现位置的迭代器，否则返回尾迭代
s.count(x);    // 返回x的个数
s.erase(x);    // 删除x
```



## map/multimap

```c++
#include <map>    // map去重，multimap不去重，均默认以key值(第一属性)升序排序，底层红黑树

map<string, int> m;

m['abc'] ++;  // m['abc'] = 1：插入'abc'，若不存在则创建，默认值为0，若存在，访问其值
m['abc'] ++;  // m['abc'] = 2
m['abc'] ++;  // m['abc'] = 3

m.size();   
m.empty();  
m.clear();
    
m.find(x);    
m.count(x); 
m.erase("abc"); // 删除键为"abc"的键值对
```



## unordered_set/unordered_map

```c++
#include <unordered_set>  // 底层哈希, 操作与set、map基本一致
#include <unordered_map>   
```



## algorithm

```c++
#include <algorithm>    

// 若要降序排序，需手写cmp函数
bool cmp(const int &a, const int &b) {
	return a > b; //降序
}
sort(a, a + n, cmp);

// 对结构体指定属性排序
// 1.重载运算符
struct Student{
	string name;
	double score;
    bool operator < (const node &a) const { //重载<运算符，必须加const，会默认按重载的小于号逻辑进行排序
        return x > a.x;  //降序
    }
}stu[N];

// 2.手写cmp函数
bool cmp(Student A,Student B){
     return A.score > B.score;  //降序
}
sort(stu, stu + n, cmp);

reverse()   //传参和sort一致，反转区间内的元素顺序
unqiue()    //传参和和sort一致，去重相邻的相同元素，若原序列无序首先需排序，返回去重后原序列尾迭代
```

